;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Test createSession
; Exercise the createSession command.  We're going to do the following:
; - confirm that commands report invalidState when called before createSession
; - confirm that createSession succeeds, and contains all required properties
; - confirm that createSession reports busy now, and others report invalidState
;
; Arguments
; (none)
;
; Locals
; createsessionresult - result of the test
; waitforeventsresult - result of waitForEvents command
;
; returns: pass or fail
;



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Display the banner...
;
echo
echo 'Test createSession v1.0 17-Jul-2017'
set createsessionresult 'pass'



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Make sure that commands prior to a successful createSession return invalidSessionId.  We don't do
; waitForEvents here, because any complaint has to come back asynchronously.  invalidSessionId takes
; precedence over invalidState, because in order to figure out what state we're in, we have to know
; what session we belong to.
;
call CHECKINVALIDSESSIONID 'getSession'
call CHECKINVALIDSESSIONID 'sendTask' '{}'
call CHECKINVALIDSESSIONID 'startCapturing'
call CHECKINVALIDSESSIONID 'readImageBlockMetadata' '1' 'false'
call CHECKINVALIDSESSIONID 'readImageBlock' '1' 'false'
call CHECKINVALIDSESSIONID 'releaseImageBlocks' '1' '1'
call CHECKINVALIDSESSIONID 'stopCapturing'
call CHECKINVALIDSESSIONID 'closeSession'
call CHECKINVALIDSESSIONID 'invalidCommand'



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Now do this test with waitForEvents
;
call WAITFOREVENTSCHECKINVALIDSESSIONID



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Call createSession, and check the return properties...
;
call CREATESESSION



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Check the codes, we're looking for commands that must return busy and invalidState
;
run 'function CheckCode' 'createsessionresult' 'createSession' 'busy'
run 'function CheckCode' 'createsessionresult' 'readImageBlockMetadata' 'invalidState' '1' 'false'
run 'function CheckCode' 'createsessionresult' 'readImageBlock' 'invalidState' '1' 'false'
run 'function CheckCode' 'createsessionresult' 'releaseImageBlocks' 'invalidState' '1' '1'
run 'function CheckCode' 'createsessionresult' 'stopCapturing' 'invalidState'



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Bye-bye...
;
echopassfail 'SUMMARY' '${get:createsessionresult}'
return '${get:createsessionresult}'



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CHECKINVALIDSESSIONID
; arg:1 - command to run
; returns pass or fail
;
:CHECKINVALIDSESSIONID
;
; Send the command...
twainlocalsession 'create'
'${arg:1}' '${arg:2}' '${arg:3}' '${arg:4}' '${arg:5}'
twainlocalsession 'destroy'
;
; Check the result...
if '${rj:results.success}' != 'false' goto CHECKINVALIDSESSIONID.FAILSTATUS
if '${rj:results.code}' != 'invalidSessionId' goto CHECKINVALIDSESSIONID.FAILCODE
;
; We're good...
echopassfail 'check invalidSessionId: ${arg:1}' 'pass'
return 'pass'
;
:CHECKINVALIDSESSIONID.FAILSTATUS
echopassfail 'check invalidSessionId: ${arg:1}' 'fail (success not false)'
set createsessionresult 'fail'
return 'fail'
;
:CHECKINVALIDSESSIONID.FAILCODE
echopassfail 'check invalidSessionId: ${arg:1}' 'fail (code not invalidSessionId)'
set createsessionresult 'fail'
return 'fail'



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; WAITFOREVENTSCHECKINVALIDSESSIONID
; returns pass or fail
;
:WAITFOREVENTSCHECKINVALIDSESSIONID
;
; Send the command...
set waitforeventsresult 'fail'
twainlocalsession 'create'
waitForEvents 'test waitForEvents' 'checkinvalidsessionid' 'waitforeventsresult'
sleep 5000
twainlocalsession 'destroy'
if '${get:waitforeventsresult}' != 'pass' goto WAITFOREVENTSCHECKINVALIDSESSIONID.FAIL
; We're good...
echopassfail 'check invalidSessionId: waitForEvents' 'pass'
return 'pass'
;
; We're not so good...
:WAITFOREVENTSCHECKINVALIDSESSIONID.FAIL
echopassfail 'check invalidSessionId: waitForEvents' 'fail'
set createsessionresult 'fail'
return 'fail'



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CREATESESSION
; returns pass or fail
;
:CREATESESSION
;
; Send the command...
createSession
;
; Check the headers...
run 'function CheckHeader' 'createsessionresult' 'Content-Type' ~contains 'application/json' 'charset=utf-8'
run 'function CheckHeader' 'createsessionresult' 'Content-Length' == '${rdata:#}'
;
; Check the mandatory properties...
run 'function CheckJsonProperty' 'createsessionresult' 'kind' == 'twainlocalscanner'
run 'function CheckJsonProperty' 'createsessionresult' 'commandId'
run 'function CheckJsonProperty' 'createsessionresult' 'method' == 'createSession'
run 'function CheckJsonProperty' 'createsessionresult' 'results'
run 'function CheckJsonProperty' 'createsessionresult' 'results.success' == 'true'
run 'function CheckJsonProperty' 'createsessionresult' 'results.session'
run 'function CheckJsonProperty' 'createsessionresult' 'results.session.sessionId' != ''
run 'function CheckJsonProperty' 'createsessionresult' 'results.session.revision' == '1'
run 'function CheckJsonProperty' 'createsessionresult' 'results.session.state' == 'ready'
if '${get:createsessionresult}' != 'pass' goto CREATESESSION.FAIL
;
; We're good...
echopassfail 'createSession call' 'pass'
return 'pass'
;
:CREATESESSION.FAIL
set createsessionresult 'fail'
echopassfail 'createSession call' 'fail'
return 'fail'
